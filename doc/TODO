RetroBASIC TODO/BUGS/ERRATA list

MS = MS BASIC, 6502 40-bit version
HP = HP Time-Sharing BASIC
AB = Atari BASIC
IB = Integer BASIC (aka Apple BASIC)
GW = GW-BASIC
WB = Wang BASIC
PA = Palo Alto Tiny BASIC
BP - DEC BASIC-PLUS

- add longer variable names

- add slicing-based concat in LET, A[10] = B[5,10]

- test and error on incorrect nesting of FOR loops, which we currently ignore

- need to allow multiple INPUTs on a single line, currently it requires a CR between values

- DEFINT/SNG/DBL/STR does not support the "range" syntax, DEFINT A-F. only comma lists work, DEFINT A,B

- needs command-line switch for ANSI, controls tab stops and many errors

- support Dartmouth/ANSI style FOR loops which skip the body if the test fails on the first loop

- ELSE would be realtively easy to add, at least the single-line variety

- flesh out GET and PUT, which are just placeholders for now

- support AB's DEG and RAD modes? WB also had gradians; SELECT G

- PA allows multiple assignments in a LET, separated by commas, see assignlist.

- BP (and HP?) allows multiple assignments with equals, A=B=C=10

- PA allows single or double quotes around strings

- PA allows # to define field widths in PRINT, so PRINT A,#3,B,C will print B and C in 3-character widths. All expressions following the format use that format until reset by another # or another PRINT

- PA prints a colon after INPUTs, not ?, and prints the variable name if no prompt is given. So "INPUT A" prints "A:", while INPUT "TYPE A NUMBER"A prints "TYPE A NUMBER:"

- LPOS, LPRINT, etc. from AB, GW and others

- file handling, OPEN, PRINT# etc.

- CINT CSNG CDBL are not implemented

- GW BASIC string formatters in PRINT USING, but number formats work

Debatable:

- backslash for statement separators seen in Multics and BASIC-PLUS. The later requires spaces on either side. Easy to convert to colons, although the formating in BASIC-PLUS documentation is nice.

- To support the "feature" (bug!) of Dartmouth and MS that an unDIMed variable is really 0..10, this code makes the minimum size for any subscript 11. Because the variables are set up at parse time, not run time, there is no easy way to know if the variable is being encountered as a DIM or calculate what the dimensions are. In theory, we could watch for DIMs at runtime and set a second set of limits to check against, leaving the original memory allocation alone, but this seems like more work than is needed given the concept of using knonw-good code. Note that BP's default DIM is 121.

Will not be done:

- WB allows RESTORE to use an ordinal position in the list, as opposed to a line number. There appears to be no easy way to distinguish this.

- WB uses CONVERT for ASC, which steps on HPs CONVERT
